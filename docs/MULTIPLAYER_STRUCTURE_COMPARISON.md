# 루카바둑: 현재 구조 vs 2인 온라인 대국 구조 비교

웹에 접속한 **사용자 2명이 서로 대결**하는 형태로 만들기 위해 필요한 구조·형식 변경을 정리했습니다.

---

## 1. 현재 구조 요약

### 1.1 아키텍처

| 항목 | 현재 |
|------|------|
| **실행 환경** | 브라우저 1개 = 게임 1개 |
| **플레이어** | 같은 기기에서 2인 **또는** 1인 vs AI |
| **상태 위치** | 전부 **클라이언트(브라우저) 메모리** |
| **서버** | 없음 (정적 HTML/JS만 서빙) |
| **통신** | 없음 (클릭 → 로컬 상태만 변경) |

### 1.2 화면/모드 흐름

```
[시작 화면] → 판 크기(9/13/19) 선택
           → "사람과 두기" → [대국 화면] (한 화면에서 흑/백 번갈아 클릭)
           → "AI와 두기"   → 돌가르기 → [대국 화면] (사람 vs AI)
```

### 1.3 상태 보관 방식

- **전역 변수** (lukabaduk-game.js)
  - `board`, `currentTurn`, `lastMove`, `capturedBlack/White`, `consecutivePass`, `gameEnded`
  - `boardHistory`, `moveHistory`, `blackMoveCount`, `whiteMoveCount`
  - `yellowAsBlack`, `yellowAsWhite` (Set)
  - `gameMode`, `humanColor`, `aiColor`, `aiGameStarted`, `showingTerritory`
- **DOM**
  - `#board`, `#turn`, `#cap-black`, `#cap-white`, `#pass-count`, `#message`
- **진행**
  - 클릭 → `placeStone()` → `doPlaceStone()` 로 **같은 프로세스 안**에서만 상태 갱신

### 1.4 행동 주체

- **사람과 두기**: 한 브라우저에서 둘 다 클릭 가능 → `currentTurn`으로만 구분
- **AI와 두기**: 사람은 클릭, AI는 `setTimeout(aiPlay)` 로 로컬에서 수 두기

---

## 2. 목표: 웹 접속자 2명이 대결

### 2.1 요구사항

- 사용자 A, B가 **서로 다른 기기/브라우저**에서 접속
- **한 판**을 두 사람이 공유 (A=흑 or 백, B=나머지)
- A가 두면 B 화면에 곧바로 반영, B가 두면 A 화면에 곧바로 반영
- 패스·한수 무르기·집계산 등도 두 클라이언트가 **동일한 상태**를 보도록 해야 함

---

## 3. 구조·형식 변경 비교

### 3.1 아키텍처

| 항목 | 현재 | 2인 온라인 대국 시 |
|------|------|---------------------|
| **클라이언트 수** | 1 | 2 (각자 브라우저) |
| **게임 상태** | 1개 브라우저 메모리 | **서버 1곳**에서 1게임당 1개 상태 보관 |
| **진행 주체** | 클라이언트가 직접 `doPlaceStone()` 등 호출 | 클라이언트는 **“수 두기/패스/무르기 요청”**만 전송, **서버가 규칙 적용 후 상태 갱신** |
| **동기화** | 없음 | 서버 → 두 클라이언트로 **실시간 푸시** (WebSocket 등) |
| **진입 방식** | 시작 화면에서 모드 선택 | **방 만들기 / 방 입장(코드·링크)** 또는 **매칭 큐** 필요 |

### 3.2 데이터 흐름

**현재 (단일 클라이언트)**

```
[사용자 클릭] → placeStone(row, col)
              → doPlaceStone() 로 board 등 직접 수정
              → updateUI(), renderStones()
              → 화면 갱신 (다른 기기 없음)
```

**2인 대국 시 (필요한 흐름)**

```
[플레이어 A 클릭] → "두기 요청" { row, col } 또는 "패스" / "무르기" 만 전송
                 → 서버: 규칙 검사 후 게임 상태 갱신
                 → 서버가 A, B 둘 다에게 "최신 상태" 또는 "마지막 수" 푸시
[플레이어 A·B]   → 수신한 상태로 board 등 덮어쓰기 → updateUI(), renderStones()
```

즉, **상태의 “진실”은 서버 1곳**에만 두고, 클라이언트는 **입력 전송 + 서버가 준 상태 반영**만 하면 됩니다.

### 3.3 필요한 추가 요소

| 구분 | 현재 | 2인 대국 시 추가 필요 |
|------|------|------------------------|
| **백엔드** | 없음 | **게임 서버** (Node.js 등): 방/매칭, 게임 상태 저장, 규칙 검증 |
| **실시간 통신** | 없음 | **WebSocket**(또는 Socket.io 등) 서버 ↔ 클라이언트 양방향 |
| **방/세션** | 없음 | **방 ID**(또는 매칭 큐)로 “같은 판”에 두 명 연결 |
| **역할 고정** | humanColor 등으로 로컬만 구분 | 서버가 **흑/백을 정해 주고**, 클라이언트는 “내 색”만 알면 됨 |
| **입장 플로우** | 없음 | **방 만들기 → 링크/코드 공유** 또는 **대기실 + 자동 매칭** UI |

---

## 4. 파일/코드 단위 변경 요약

### 4.1 새로 필요한 것

- **서버 (백엔드)**
  - 게임 상태를 담는 **방(room)** 개념 (방 ID, board, currentTurn, moveHistory, yellowAsBlack/White 등)
  - 수 두기/패스/무르기 **요청** 수신 → **규칙 검증** (doPlaceStone 로직을 서버로 이식 또는 공유) → 상태 갱신 → 두 클라이언트에 **브로드캐스트**
  - WebSocket(또는 Socket.io)으로 **연결·방 입장·이벤트 송수신**
- **클라이언트**
  - **소켓 연결** (같은 방으로 입장)
  - **내 색**(흑/백) 표시, **내 차례일 때만** 착수/패스/무르기 버튼 활성화
  - **서버에서 받은 이벤트**로 `board`, `currentTurn` 등 덮어쓰기 후 `renderStones()`, `updateUI()` 호출

### 4.2 기존 것의 역할 변경

| 현재 | 2인 대국 시 |
|------|-------------|
| **doPlaceStone(row, col)** | 클라이언트: “두기 요청”만 보냄. 서버에 **동일 규칙** 구현해 서버가 doPlaceStone 수행 후 결과만 브로드캐스트 |
| **placeStone(row, col)** | 클릭 시 **서버로 { row, col } 전송**만 하고, 화면 갱신은 **서버 이벤트 수신 시** 수행 |
| **passTurn() / undoMove()** | 마찬가지로 **패스/무르기 요청** 전송 → 서버가 처리 후 전체 상태(또는 차이분) 푸시 |
| **gameMode, humanColor, aiColor, aiPlay** | **AI 모드**는 그대로 로컬 전용으로 두고, **온라인 2인 모드**는 `gameMode === 'online'`, `myColor`(서버에서 받은 내 색) 만 추가해 구분 |
| **board, moveHistory 등** | **서버가 내려준 값으로 덮어쓰기**하는 경로 추가 (로컬에서 직접 doPlaceStone 호출하는 경로와 분리) |

### 4.3 화면/플로우 변경

**현재**

- 시작 → 사람과 두기 / AI와 두기 → (바로 또는 돌가르기 후) 대국 화면

**2인 대국 시**

- 시작 → **온라인 대국** 선택  
  - **방 만들기**: 방 ID(또는 링크) 생성 → 대기 화면 (“상대 입장 대기”)  
  - **방 입장**: 방 ID/링크 입력 → 입장 → 대기 또는 바로 대국  
- **두 명 다 들어오면** 서버가 흑/백 배정(예: 먼저 들어온 쪽 흑) → 대국 화면으로 전환  
- 대국 화면: **내 차례일 때만** 착수·패스·무르기 가능, 상대 차례일 때는 “상대가 두는 중” 등 표시

---

## 5. 상태 직렬화(서버·클라이언트 간 주고받기)

현재는 전부 **메모리(객체·Set)**라서 그대로 보낼 수 없으므로, **주고받을 형식**이 필요합니다.

| 현재 (메모리) | 전송용으로 바꿀 때 |
|---------------|--------------------|
| `board` (2차원 숫자 배열) | 그대로 JSON `[[0,1,...], ...]` |
| `yellowAsBlack`, `yellowAsWhite` (Set) | 배열로: `["1,2","3,4"]` 등 |
| `moveHistory` (객체 배열) | 그대로 JSON 배열 (각 항목에 row, col, stone, capturedStones 등) |
| `currentTurn`, `lastMove`, `capturedBlack/White`, `consecutivePass`, `gameEnded`, `blackMoveCount`, `whiteMoveCount` | 그대로 숫자/boolean 등 JSON 호환 타입으로 |

- **서버 → 클라이언트**: “전체 상태” 한 번 보내기 또는 “마지막 수 + 보드 스냅샷” 등 최소한만 보내도 됨.
- **클라이언트**: 수신한 JSON으로 위 전역 변수들을 복원한 뒤 `renderStones()`, `updateUI()` 호출.

---

## 6. 정리: 변경 포인트 체크리스트

- **백엔드**
  - [ ] WebSocket(또는 Socket.io) 서버 구축
  - [ ] 방 생성/입장/퇴장 및 방 ID(또는 링크) 관리
  - [ ] 게임 규칙 로직 서버 이식 (doPlaceStone, 패스, 무르기, 연속 패스 시 종료 등)
  - [ ] 상태를 JSON 등으로 직렬화해 클라이언트에 푸시
- **클라이언트**
  - [ ] 소켓 연결 및 “방 입장” 플로우
  - [ ] “내 색” 표시, 내 차례일 때만 착수/패스/무르기 허용
  - [ ] 수 두기/패스/무르기는 “요청 전송”만, 화면 갱신은 “서버 이벤트 수신 시”만
  - [ ] 서버에서 받은 상태로 board, moveHistory, yellowAsBlack/White 등 복원 후 렌더
- **UI**
  - [ ] 시작 화면에 “온라인 대국” (방 만들기 / 방 입장) 추가
  - [ ] 대기 화면 추가
  - [ ] 대국 화면에서 “상대 차례 / 내 차례” 구분 표시

이렇게 변경하면 **지금 구조**와 **2명이 웹에서 대결하는 구조**의 차이를 명확히 맞출 수 있고, 실제 구현 시 단계별로 적용할 수 있습니다.
